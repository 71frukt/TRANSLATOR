# Компилятор Панк-языка
Шелонин Арсений, студент 1 курса ФРКТ МФТИ 

## Описание проекта
Проект представляет собой компилятор, который переводит текст программы, написанной на моём языке, в код для написанного мной эмулятора ассемблера. 

## Сборка и запуск
*Программа написана для системы Windows.*

### Сборка проекта:

1. Клонируйте репозиторий
```bash
$ git clone https://github.com/71frukt/PUNK_LANGUAGE.git
```

2. Соберите проект
```bash
$ make
```

### Сборка и запуск вашей программы

1. Сборка
```bash
$ compile <your_code_file> <asm_file>
```

<details>
<summary>Для запуска frontend, middlend и backend частей по отдельности</summary>

```bash
$ cd frontend/build
$ frontend.exe <input_file> <output_file>
$ cd ../..
```

```bash
$ cd middlend/build
$ middlend.exe <input_file> <output_file>
$ cd ../..
```

```bash
$ cd backend/build
$ backend.exe <input_file> <output_file>
$ cd ../..
```

</details>
<br>

2. Запуск
```bash
$ run <asm_file>
```

## Синтаксис языка
### 1. Общие правила
Общая структура схожа со структурой языка Си. Ключевые детали:
* В программе должна существовать главная функция `MAIN_HOI`, в которой начнётся и закончится выполнение программы.
* Все числовые значения имеют единый тип - `int`.
* Функции могут принимать неограниченное количество аргументов.
* Имена переменных должны быть на английском языке
* Слова не на английском языке и не являющиеся ключевыми считаются комментариями

Панк-язык создаёт внутри стековый фрейм, что позволяет использовать в программах рекурсию, вложенные вызовы функций и области видимости. Для каждого блока - части кода, обособленной фигурными скобками в Си или соответствующими им управляющими словами в Панк-языке - создаётся своя таблица имён. Это позволяет создавать локальные переменные в разных блоках кода и называть их одинаково.

### 2. Синтаксис
Синтаксис языка делится на три подгруппы: ключевые слова, управляющие слова и математические операторы.

### Ключевые слова

|Слово в Панк-языке | Аналог в Си | 
|-------------------|-------------|
| целый             |    int      |
| хой               |      ;      |
| вместе            |      ,      |
| теперь            |      =      |
| коль              |     if      |
| пока              |    while    |
| лес               |    return   |
| почитаю           |    scanf    |
| болтал            |    printf   |

### Управляющие слова
|Слово в Панк-языке | Аналог в Си | 
|-------------------|-------------|
| панки_хой         |      {      |
| попса_отстой      |      }      |
| желаешь           |      (      |
| расскажу          |      )      |

### Математические операции

| Слово в Панк-языке  | Аналог в Си |
|---------------------|-------------|
| будто               | ==          |
| ну_нафиг            | !=          |
| хиленький           | <           |
| мощный              | >           |
| накину              | +           |
| сдеру               | -           |
| помножу             | *           |
| порублю             | /           |
| накорню             | sqrt        |
| вздыбить            | pow         |
| натурально          | ln          |


## Примеры программ

### Решение квадратного уравнения
Эта программа вычисляет решение уравнения $Ax^2 + Bx + C = 0$ , коэффициенты которого вводятся с консоли по очереди. Она иллюстрирует использование локальных переменных и вызовов функций с нескольким количеством переменных. Программа возвращает $666$, если решений нет, и $777$, если их бесконечно много. 

<details>
<summary>Решение квадратного уравнения на Панк-языке</summary>

```
будь как дома путник йа ни в чём не откажу
йа ни в чём не откажу
йа ни в чём не откажу

целый MAIN_HOI историй желаешь целый arg расскажу
панки_хой
    целый a теперь почитаю хой
    целый b теперь почитаю хой 
    целый c теперь почитаю хой

    коль желаешь a будто 0 расскажу
    панки_хой
        болтал Linerial желаешь b , c расскажу хой
        лес 0 хой
    попса_отстой

    целый discr теперь b помножу b сдеру 4 помножу a помножу c хой

    коль желаешь discr хиленький 0 расскажу
    панки_хой
        болтал 666 хой
        лес 0 хой
    попса_отстой

    коль желаешь discr будто 0 расскажу
    панки_хой
        болтал желаешь 0 сдеру b расскажу порублю 2 порублю a хой
        лес 0 хой
    попса_отстой

    целый x1 теперь желаешь 0 сдеру b сдеру корень желаешь discr расскажу расскажу порублю 2 порублю a хой
    целый x2 теперь желаешь 0 сдеру b накину корень желаешь discr расскажу расскажу порублю 2 порублю a хой

    болтал x1 хой
    болтал x2 хой

    лес 0 хой
попса_отстой

будь как дома путник йа ни в чём не откажу
йа ни в чём не откажу
йа ни в чём не откажу

целый Linerial историй желаешь целый b вместе с целый c расскажу
панки_хой
    коль желаешь b будто 0 расскажу
    панки_хой
        коль желаешь с будто 0
        панки_хой
            лес 777
        попса_отстой

        лес 666 хой
    попса_отстой

    И волки среди ночи завыли под окном
    Старик заулыбался и вдруг покинул дом
    Но вскоре возвратился с ружьём наперевес
    друзья хотят покушать пойдём приятель в лес 0 сдеру b порублю c хой
попса_отстой
```
</details>


<details>
<summary>Аналогичная программа на псевдокоде</summary>

```C
int main()
{
    int a = ReadInput;
    int b = ReadInput;
    int c = ReadInput;

    if (a == 0)
    {
        PrintOutput(Linerial(b, c));
        return 0;
    }

    int discr = b * b - 4 * a * c;

    if (discr < 0)
    {
        PrintOutput(666);
        return 0;
    }

    int x1 = (0 - b - sqrt(discr)) / 2 / a;
    int x1 = (0 - b + sqrt(discr)) / 2 / a;

    PrintOutput(x1);
    PrintOutput(x2);

    return 0;
}

int Linerial(int b, int c)
{
    if (b == 0)
    {
        if (c == 0)
            return(777);

        return(666);
    }

    return 0 - c / b;
}
```
</details>



### Вычисление факториала числа
Эта программа иллюстрирует возможности рекурсивного вызова функций. Она рекурсивно вычисляет значение факториала введенного в консоль числа.

<details>
<summary>Факториал на Панк-языке</summary>

```
будь как дома путник йа ни в чём не откажу
йа ни в чём не откажу
йа ни в чём не откажу

целый MAIN_HOI историй желаешь целый a расскажу
панки_хой
    И волки среди ночи завыли под окном
    Старик заулыбался и вдруг покинул дом
    Но вскоре возвратился с ружьём наперевес
    лес fact желаешь почитаю расскажу хой
попса_отстой

будь как дома путник йа ни в чём не откажу
йа ни в чём не откажу
йа ни в чём не откажу

целый fact желаешь в не целый n расскажу 
панки_хой
    коль желаешь n хиленький 1 значит мало расскажу
    панки_хой
        не пойдём приятель в лес 1 хой
    попса_отстой

    И волки среди ночи завыли под окном
    Старик заулыбался и вдруг покинул дом
    Но вскоре возвратился с ружьём наперевес
    друзья хотят покушать 
    пойдём приятель в лес n помножу fact желаешь n сдеру 1 расскажу хой
попса_отстой
```

</details>

<details>
<summary>Аналог на псевдокоде</summary>

```C
int main()
{
    return fact(ReadInput());
}

int fact(int n)
{
    if (n < 1)
        return 1;

    return n * fact(n - 1);
}
```
</details>


## Принцип работы компиллятора
Работа программы разделена на три этапа:
### 1. Frontend

Преобразует написанный на Панк-языке код в соответствующее ему дерево. Затем это дерево преобразуется в файл стандартизированного формата, который потом считывают другие этапы, восстанавливая по нему дерево для дальнейшей работы с ним. 

_Граф, полученный после работы фронтэнда_
![alt text](readme/fr_graph.png)

### 2. Middle-end 

Читает дерево из файла оптимизирует его, сворачивая константы и условные переходы, результат которых известен на этапе компиляции. Результат работы так же записывается в файл.

| До оптимизации                        | После оптимизации                         |
|---------------------------------------|-------------------------------------------|
| ![alt text](readme/bef_opt_const.png) | ![alt text](readme/aft_opt_const.png)     |
| ![alt text](readme/bef_opt_if.png)    | ![alt text](readme/aft_opt_if.png)        |


### 3. Backend 

Считывает дерево из файла и переводит его в ассемблерный код. Он организует стековый фрейм и организует всю работу с памятью. 

Вот пример созданного ассемблерного кода, соответствующего вызову функции `Linerial(int b, int c)` и началу её кода из программы решения квадратного уравнения:

_Место, где вызывается функция_
```asm
    ...

    ; вызов функции 'Linerial'   
    PUSH AX   
    ; передача аргументов в функцию 
    PUSH [AX + 3]
    PUSH [AX + 2]
    PUSH BX   
    POP AX   
    CALL Linerial: 
    POP CX  
    PUSH AX  
    POP BX  
    POP AX  
    PUSH CX  
    ; конец вызова функции 'Linerial'   

    ...
```

_Начало реализации функции_
```asm
Linerial:
	; инициализация переменной 'b'   
    POP [BX] 
    PUSH BX   
    PUSH 1    
    ADD      
    POP BX   
	; инициализация переменной 'c'   
    POP [BX] 
    PUSH BX   
    PUSH 1    
    ADD       

    ...
```


Таким образом, проект реализует базовые принципы настоящего языка и обладает минимальным набором возможностей, позволяющих писать осмысленный код.