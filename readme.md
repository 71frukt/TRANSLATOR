# Компилятор Панк-языка
Шелонин Арсений, студент 1 курса ФРКТ МФТИ 

## Описание проекта
Проект представляет собой продолжение [работы](https://github.com/71frukt/PUNK_LANGUAGE) из прошлого семестра. Он преобразует ваш код, написанный на моём панк-языке в исполняемый ELF-файл.

## Сборка и запуск
*Программа написана для системы Linux x86-64.*

### Сборка проекта:

```bash
$ git clone --recursive https://github.com/71frukt/PUNK_LANGUAGE.git
```

```bash
$ make
```

**Команды make:**
* `run_translator` - запуск трансляции в ELF-файл
* `benchmark_translator`, `benchmark_spu` - замер времени работы программ, полученных транслятором в ассемблер и [компилятором](https://github.com/71frukt/PUNK_LANGUAGE) в мой ассемблер для [виртуального процессора](https://github.com/71frukt/SPU). 



## Синтаксис языка
### 1. Общие правила
Общая структура схожа со структурой языка Си. Ключевые детали:
* В программе должна существовать главная функция `MAIN_HOI`, в которой начнётся и закончится выполнение программы.
* Все числовые значения имеют единый тип - `int`.
* Функции могут принимать неограниченное количество аргументов.
* Имена переменных должны быть на английском языке
* Слова не на английском языке и не являющиеся ключевыми считаются комментариями

Панк-язык создаёт внутри стековый фрейм, что позволяет использовать в программах рекурсию и вложенные вызовы функций:

*Функция факториала на читаемом языке (не таком как мой :))*
```
инт fact ( инт n ) 
{
    если ( n < 1 )
    {
        рет 1 ;
    }
    
    рет n * fact ( n - 1 ) ;
}
```

Также каждый блок - часть кода, обрамленная фигурными скобками в примере и `панки_хой`, `попса_отстой` соответственно в моем синтаксисе - имеет свою таблицу имен, что позволяет языку поддерживать области видимости.

```
инт MAIN_HOI ( инт a )
{
    если ( 1 < 500 )
    {
        инт local = 777 ;
        принт ( local ) ;
    }

    инт local = 888 ; 
    принт ( local ) ;

    рет 0 ;
}
```

Программа отличает эти переменные:
```bash
./translator
777
888
```

Если же использовать во внешнем блоке переменную, определенную во внутреннем - синтаксический анализ выдаст ошибку: 
``` bash
SyntaxError called in src/tree.cpp:305 GetBlockNamesTable()
Error: Undefined variable named 'local'   (position 8:9)
```


### 2. Синтаксис
Синтаксис языка делится на три подгруппы: ключевые слова, управляющие слова и математические операторы.

### Ключевые слова

|Слово в Панк-языке | Аналог в Си | 
|-------------------|-------------|
| целый             |    int      |
| хой               |      ;      |
| вместе            |      ,      |
| теперь            |      =      |
| коль              |     if      |
| пока              |    while    |
| лес               |    return   |
| почитаю           |    scanf    |
| болтал            |    printf   |

### Управляющие слова
|Слово в Панк-языке | Аналог в Си | 
|-------------------|-------------|
| панки_хой         |      {      |
| попса_отстой      |      }      |
| желаешь           |      (      |
| расскажу          |      )      |

### Математические операции

| Слово в Панк-языке  | Аналог в Си |
|---------------------|-------------|
| будто               | ==          |
| ну_нафиг            | !=          |
| хиленький           | <           |
| хиленький           | <           |
| перехиленький       | <=          |
| недомощный          | >=          |
| накину              | +           |
| сдеру               | -           |
| помножу             | *           |
| порублю             | /           |


## Примеры программ

### Решение квадратного уравнения
Эта программа вычисляет решение уравнения $Ax^2 + Bx + C = 0$ , коэффициенты которого вводятся с консоли по очереди. Она иллюстрирует использование локальных переменных и вызовов функций с нескольким количеством переменных. Программа возвращает $666$, если решений нет, и $777$, если их бесконечно много. 

<details>
<summary>Решение квадратного уравнения на Панк-языке</summary>

```
будь как дома путник йа ни в чём не откажу
йа ни в чём не откажу
йа ни в чём не откажу

целый MAIN_HOI историй желаешь целый arg расскажу
панки_хой
    целый a теперь почитаю хой
    целый b теперь почитаю хой 
    целый c теперь почитаю хой

    коль желаешь a будто 0 расскажу
    панки_хой
        болтал Linerial желаешь b , c расскажу хой
        лес 0 хой
    попса_отстой

    целый discr теперь b помножу b сдеру 4 помножу a помножу c хой

    коль желаешь discr хиленький 0 расскажу
    панки_хой
        болтал 666 хой
        лес 0 хой
    попса_отстой

    коль желаешь discr будто 0 расскажу
    панки_хой
        болтал желаешь 0 сдеру b расскажу порублю 2 порублю a хой
        лес 0 хой
    попса_отстой

    целый x1 теперь желаешь 0 сдеру b сдеру корень желаешь discr расскажу расскажу порублю 2 порублю a хой
    целый x2 теперь желаешь 0 сдеру b накину корень желаешь discr расскажу расскажу порублю 2 порублю a хой

    болтал x1 хой
    болтал x2 хой

    лес 0 хой
попса_отстой

будь как дома путник йа ни в чём не откажу
йа ни в чём не откажу
йа ни в чём не откажу

целый Linerial историй желаешь целый b вместе с целый c расскажу
панки_хой
    коль желаешь b будто 0 расскажу
    панки_хой
        коль желаешь с будто 0
        панки_хой
            лес 777
        попса_отстой

        лес 666 хой
    попса_отстой

    И волки среди ночи завыли под окном
    Старик заулыбался и вдруг покинул дом
    Но вскоре возвратился с ружьём наперевес
    друзья хотят покушать пойдём приятель в лес 0 сдеру b порублю c хой
попса_отстой
```
</details>


<details>
<summary>Аналогичная программа на псевдокоде</summary>

```C
int main()
{
    int a = ReadInput;
    int b = ReadInput;
    int c = ReadInput;

    if (a == 0)
    {
        PrintOutput(Linerial(b, c));
        return 0;
    }

    int discr = b * b - 4 * a * c;

    if (discr < 0)
    {
        PrintOutput(666);
        return 0;
    }

    int x1 = (0 - b - sqrt(discr)) / 2 / a;
    int x1 = (0 - b + sqrt(discr)) / 2 / a;

    PrintOutput(x1);
    PrintOutput(x2);

    return 0;
}

int Linerial(int b, int c)
{
    if (b == 0)
    {
        if (c == 0)
            return(777);

        return(666);
    }

    return 0 - c / b;
}
```
</details>



### Вычисление факториала числа
Эта программа иллюстрирует возможности рекурсивного вызова функций. Она рекурсивно вычисляет значение факториала введенного в консоль числа.

<details>
<summary>Факториал на Панк-языке</summary>

```
будь как дома путник йа ни в чём не откажу
йа ни в чём не откажу
йа ни в чём не откажу

целый MAIN_HOI историй желаешь целый a расскажу
панки_хой
    И волки среди ночи завыли под окном
    Старик заулыбался и вдруг покинул дом
    Но вскоре возвратился с ружьём наперевес
    лес fact желаешь почитаю расскажу хой
попса_отстой

будь как дома путник йа ни в чём не откажу
йа ни в чём не откажу
йа ни в чём не откажу

целый fact желаешь в не целый n расскажу 
панки_хой
    коль желаешь n хиленький 1 значит мало расскажу
    панки_хой
        не пойдём приятель в лес 1 хой
    попса_отстой

    И волки среди ночи завыли под окном
    Старик заулыбался и вдруг покинул дом
    Но вскоре возвратился с ружьём наперевес
    друзья хотят покушать 
    пойдём приятель в лес n помножу fact желаешь n сдеру 1 расскажу хой
попса_отстой
```

</details>

<details>
<summary>Аналог на псевдокоде</summary>

```C
int main()
{
    return fact(ReadInput());
}

int fact(int n)
{
    if (n < 1)
        return 1;

    return n * fact(n - 1);
}
```
</details>


## Принцип работы компиллятора
Работа программы разделена на три этапа:
## 1. Frontend

Преобразует написанный на Панк-языке код в соответствующее ему дерево. Затем это дерево преобразуется в файл стандартизированного формата, который потом считывают другие этапы, восстанавливая по нему дерево для дальнейшей работы с ним. 

_Граф, полученный после работы фронтэнда_
![alt text](readme_images/fr_graph.png)

## 2. Middle-end 

Читает дерево из файла оптимизирует его, сворачивая константы и условные переходы, результат которых известен на этапе компиляции. Результат работы так же записывается в файл.

| До оптимизации                               | После оптимизации                            |
|----------------------------------------------|--------------------------------------------- |
| ![alt text](readme_images/bef_opt_const.png) | ![alt text](readme_images/aft_opt_const.png) |
| ![alt text](readme_images/bef_opt_if.png)    | ![alt text](readme_images/aft_opt_if.png)    |


## 3. Построение IR и ELF-файла

Для простоты построения бинарного кода и приятного дебага удобно работать не с девовидным представлением кода, а линейным. Для этого сначала из дерева строится Linear Intermediate Representation (далее - просто IR), а затем из него линейно собирается ассемблерный код. IR состоит из базовых блоков - последовательностей инструкций в IR с одной точкой входа и одной точкой выхода, без ветвлений внутри. Например, вот IR для показанной выше функции факториала:


```
func(func_3_1)		                    # int fact(1 args)
		operation(tmp_0, <, var_0, 1)       # tmp_0 = var_0 < 1
		neg_cond_jump(label_0, tmp_0)       # jne label_0
		return(1)

		
	local_label(label_0)
		operation(tmp_1, -, var_0, 1)       # tmp_1 = var_0 - 1
		assign(arg_0, tmp_1)                # arg_0 = tmp_1
		call_func(tmp_2, func_3_1)		    # call fact(1 args)
		operation(tmp_3, *, var_0, tmp_2)   # tmp_3 = var_0 * tmp_2
		return(tmp_3)
```

## Структура IR:
| Base Block name         | Return value      | Operation      | Label       | First Operand       | Second Operand    |
|------------------------ |-------------------|----------------|------------ |---------------------|-------------------|
| `Call function`         | Tmp               | None           | None        | Func label          | None              |
| `Function body`         | None              | None           | Func label  | Number of arguments | None              |
| `(neg) Conditional jump`| None              | None           | None        | Local label         | Tmp               |
| `Assignment`            | None              | None           | None        | Var or Tmp or Arg   | Var or Tmp or Num |
| `Operation`             | Tmp               | math operation | None        | Var or Tmp or Num   | Var or Tmp or Num |
| `Local label`           | None              | None           | Local Label | None                | None              |
| `Return`                | Tmp or var or Num | None           | None        | None                | None              |
| `Call system function`  | Tmp               | None           | Func label  | Var or Tmp or Num   | None              |

### Структура базового блока
```C
struct IrBlock
{
    IrBlockType     block_type;
    IrOperationType op_type;      

    IrOperand ret_operand;
    IrOperand operand_1; 
    IrOperand operand_2;

    Label label;

    ON_IR_DEBUG(
    char comment[COMMENT_LEN];
    )
};

```

### О типах операндов базового блока

### 1. `tmp`
Временные переменные, хранящиеся на верхушке стека. Используются в математических и логических операциях, вызовах функций. IR разбивает все сложные операции на последовательную работу с tmp-переменными. Например, математическое выражение
```
инт x = 1 ;
инт y = 5 * x + 9 - 8 - x ;
```
 преобразуется в последовательность базовых блоков:

```
assign(var_1, 1)		            # int x = 1
operation(tmp_0, *, 5, var_1)       # tmp_0 = 5 * var_1
operation(tmp_1, +, tmp_0, 9)       # tmp_1 = tmp_0 + 9
operation(tmp_2, -, tmp_1, 8)       # tmp_2 = tmp_1 - 8
operation(tmp_3, -, tmp_2, var_1)   # var_1 = tmp_2 - var_1
assign(var_2, tmp_3)		        # int y
```

### 2. `var`

Это переменные, определенные пользователем. Имеют зарезервированное место в стековом фрейме в своей области видимости. 

#### Про области видимости
Для каждого блока в дереве отделяется отдельный узел с именем `new_block`. В нем находится его собственная таблица имен, в которой каждой переменной определен номер. Цель таблиц имён - получить смещение каждой переменной относительно начала стекового фрейма. Стоит пояснить, как это рассчитывается в моём случае. 

Пусть есть некоторый блок, в котором также находится m других блоков. Тогда пусть в k-том блоке(до которого в изначальном блоке было определено `p` переменных) определена переменная `var_n`, n-тая в этом блоке. Тогда смещение относительно начального блока равно `shift = (p + n) * sizeof(var)`. Так рекурсивно определяется глобальное смещение относительно блока функции, и любая переменная становится доступна по адресу `[rbp - shift]`.


<image src="readme_images/name_tables.png" alt="3s" width=60%>

### 3. `label`
Существует два вида меток - локальные метки и метки для функций. Метка для функций также содержит информацию о количестве аргументов. Условия и циклы в IR представляются как последовательность условных переходов на локальные метки.

### 4. `arg`
Обозначает положение аргумента функции в стек - просто удобный синтаксис. 

### Поля базовых блоков

|  Поле           |   Пояснение        
|-----------------|----------------------------------------------------------
| Base Block name | Имя базового блока 
| Return value    | Возвращаемое значение блока - может быть только `tmp`
| Operation       | Если блок типа операции - это поле равно соответствующему номеру математической операции
| Label           | Собственная метка блока. Очевидно, что определена только для тела функции или локальной метки
| 1-st, 2-nd operands | Соответствующие 1 и 2 операнды блока


## Построение ELF-файла
Имея на руках IR, построение ELF-файла становится сильно проще. ELF-файл состоит из нескольких частей:
### 1. ELF-заголовок (ELF-Header) - содержит метаинформацию о файле.

**Структура ELF-заголовка**

```C
struct ElfHeader
{
    unsigned char e_ident[16];  // Магия (0x7F 'E' 'L' 'F'), битность (32/64), endianness, версия ELF
    uint16_t      e_type;       // Тип файла (ET_EXEC, ET_DYN, ET_REL)
    uint16_t      e_machine;    // Архитектура (EM_X86_64 = 0x3E)
    uint32_t      e_version;    // Версия ELF (обычно EV_CURRENT = 1)
    uint64_t      e_entry;      // Точка входа (адрес, где начинается выполнение)
    uint64_t      e_phoff;      // Смещение до Program Headers
    uint64_t      e_shoff;      // Смещение до Section Headers (может быть 0)
    uint32_t      e_flags;      // Флаги (для x86-64 обычно 0)
    uint16_t      e_ehsize;     // Размер ELF-заголовка (64 байта)
    uint16_t      e_phentsize;  // Размер одного Program Header
    uint16_t      e_phnum;      // Количество Program Headers
    uint16_t      e_shentsize;  // Размер одного Section Header
    uint16_t      e_shnum;      // Количество Section Headers
    uint16_t      e_shstrndx;   // Индекс строковой таблицы секций (может быть 0)
};
```


### 2. Таблица программных заголовков (Program Header Table) - содержит информацию о сегментaх, описывающие, как файл должен быть загружен в память.

**Структура ProgramHeader**

```C
struct ProgramHeader
{
    uint32_t  p_type;           // Тип сегмента (PT_LOAD = 1)
    uint32_t  p_flags;          // Флаги (PF_X, PF_W, PF_R)
    uint64_t  p_offset;         // Смещение в файле
    uint64_t  p_vaddr;          // Виртуальный адрес в памяти
    uint64_t  p_paddr;          // Физический адрес (обычно = vaddr)
    uint64_t  p_filesz;         // Размер в файле
    uint64_t  p_memsz;          // Размер в памяти
    uint64_t  p_align;          // Выравнивание
};
```


### 3. Таблица секций (Section Header Table) - содержит информацию о секциях

#### Виды секций

```
.text     — исполняемый код.
.data     — инициализированные данные.
.bss      — неинициализированные данные (в файле не занимает места).
.rodata   — read-only данные (строковые константы).
.symtab   — таблица символов.
.strtab   — таблица строк.
.rel.*    — информация о релокациях.
.dynamic  — данные для динамической линковки.
.shstrtab — имена секций.
```


#### Структура Заголовка секции

```C
struct SectionHeader
{
    uint32_t sh_name;           // смещение в .shstrtab до имени секции    
    uint32_t sh_type;           // тип секции (SHT_PROGBITS, SHT_STRTAB, ...)
    uint64_t sh_flags;          // флаги доступа   
    uint64_t sh_addr;           // адрес в памяти
    uint64_t sh_offset;         // смещение секции в файле    
    uint64_t sh_size;           // размер секции
    uint32_t sh_link;           // зависит от типа (например, .symtab ссылается на strtab)    
    uint32_t sh_info;           // доп информация, зависит от типа
    uint64_t sh_addralign;      // требуемое выравнивание    
    uint64_t sh_entsize;        // размер элемента, если это таблица
};
```

В нашем случае будут использоваться только .text - для кода, и .shstrtab - обязательная секция которая хранит имена всех секций.

#### Про выравнивание
Стоит также отметить, что секция **.text** в файле должна быть выровнена по **0x10** байт, **.shstrtab** - по **0x01** (то есть без выравнивания), а элементы таблицы заголовков секций - по **0x10** байт.

Итого, получаем исполняемый ELF-файл, соответствующий написанному на моём языке коду.

## Сравнение производительности с версией на виртуальном процессоре

### Эталонная машина
* Процессор - Intel Core Ultra 5 125H
* Частота процессора при измерениях - 2000MHz
* OC - Manjaro Linux

Программа запускалась и тестировалась следующими инструментами:

| Программа       |  Версия         |
|-----------------|-----------------|
| gcc             | 14.2.1          |
| perf            | 6.14-1          |
| cpupower        | 6.14-1          |
| nice            | 9.6             |


Тестировать будем программу расчёта факториала от 5 в цикле с 500 итерациями:

<details>
<summary>Тестируемая программа</summary>

```C
инт MAIN_HOI ( инт a )
{
    инт i = 0 ;

    пока ( i < 500 )
    {
        fact ( 5 ) ;
        i = i + 1 ;
    }

    рет 0 ;
}

инт fact ( инт n ) 
{
    если ( n < 1 )
    {
        рет 1 ;
    }
    
    рет n * fact ( n - 1 ) ;
}
```
</details>

<br>


Полученные результаты:

|Эксперимент | Транслятор в бинарник | Транслятор в мой ассемблер для виртуального процессора |
|------------|------------------------|--------------------|
| 1          | 15 154                 | 28 244 569     |
| 2          | 20 679                 | 27 597 657     |
| 3          | 21 565                 | 27 436 504     |
| 4          | 22 156                 | 29 223 703     |
| 5          | 19 564                 | 28 974 738     |
| 6          | 25 654                 | 28 287 638     |
| 7          | 24 915                 | 30 151 235     |
| 8          | 20 678                 | 27 865 057     |
| 9          | 20 984                 | 28 004 734     |
| 10         | 21 975                 | 28 377 252     |
|**среднее** | **21332**              | **28 616 308** |


То есть мы получили прирост в около **1300 раз**. 



Таким образом, проект реализует базовые принципы настоящего языка и обладает набором возможностей, позволяющих писать осмысленный код.

